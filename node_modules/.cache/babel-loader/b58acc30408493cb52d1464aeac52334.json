{"ast":null,"code":"import { Rect } from '../../../utilities/geometry.js';\n\nfunction calculateVerticalPosition(activatorRect, overlayRect, overlayMargins, scrollableContainerRect, containerRect, preferredPosition, fixed) {\n  const activatorTop = activatorRect.top;\n  const activatorBottom = activatorTop + activatorRect.height;\n  const spaceAbove = activatorRect.top;\n  const spaceBelow = containerRect.height - activatorRect.top - activatorRect.height;\n  const desiredHeight = overlayRect.height;\n  const verticalMargins = overlayMargins.activator + overlayMargins.container;\n  const minimumSpaceToScroll = overlayMargins.container;\n  const distanceToTopScroll = activatorRect.top - Math.max(scrollableContainerRect.top, 0);\n  const distanceToBottomScroll = containerRect.top + Math.min(containerRect.height, scrollableContainerRect.top + scrollableContainerRect.height) - (activatorRect.top + activatorRect.height);\n  const enoughSpaceFromTopScroll = distanceToTopScroll >= minimumSpaceToScroll;\n  const enoughSpaceFromBottomScroll = distanceToBottomScroll >= minimumSpaceToScroll;\n  const heightIfBelow = Math.min(spaceBelow, desiredHeight);\n  const heightIfAbove = Math.min(spaceAbove, desiredHeight);\n  const containerRectTop = fixed ? 0 : containerRect.top;\n  const positionIfAbove = {\n    height: heightIfAbove - verticalMargins,\n    top: activatorTop + containerRectTop - heightIfAbove,\n    positioning: 'above'\n  };\n  const positionIfBelow = {\n    height: heightIfBelow - verticalMargins,\n    top: activatorBottom + containerRectTop,\n    positioning: 'below'\n  };\n\n  if (preferredPosition === 'above') {\n    return (enoughSpaceFromTopScroll || distanceToTopScroll >= distanceToBottomScroll && !enoughSpaceFromBottomScroll) && (spaceAbove > desiredHeight || spaceAbove > spaceBelow) ? positionIfAbove : positionIfBelow;\n  }\n\n  if (preferredPosition === 'below') {\n    return (enoughSpaceFromBottomScroll || distanceToBottomScroll >= distanceToTopScroll && !enoughSpaceFromTopScroll) && (spaceBelow > desiredHeight || spaceBelow > spaceAbove) ? positionIfBelow : positionIfAbove;\n  }\n\n  if (enoughSpaceFromTopScroll && enoughSpaceFromBottomScroll) {\n    return spaceAbove > spaceBelow ? positionIfAbove : positionIfBelow;\n  }\n\n  return distanceToTopScroll > minimumSpaceToScroll ? positionIfAbove : positionIfBelow;\n}\n\nfunction calculateHorizontalPosition(activatorRect, overlayRect, containerRect, overlayMargins, preferredAlignment) {\n  const maximum = containerRect.width - overlayRect.width;\n\n  if (preferredAlignment === 'left') {\n    return Math.min(maximum, Math.max(0, activatorRect.left - overlayMargins.horizontal));\n  } else if (preferredAlignment === 'right') {\n    const activatorRight = containerRect.width - (activatorRect.left + activatorRect.width);\n    return Math.min(maximum, Math.max(0, activatorRight - overlayMargins.horizontal));\n  }\n\n  return Math.min(maximum, Math.max(0, activatorRect.center.x - overlayRect.width / 2));\n}\n\nfunction rectIsOutsideOfRect(inner, outer) {\n  const {\n    center\n  } = inner;\n  return center.y < outer.top || center.y > outer.top + outer.height;\n}\n\nfunction intersectionWithViewport(rect) {\n  let viewport = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : windowRect();\n  const top = Math.max(rect.top, 0);\n  const left = Math.max(rect.left, 0);\n  const bottom = Math.min(rect.top + rect.height, viewport.height);\n  const right = Math.min(rect.left + rect.width, viewport.width);\n  return new Rect({\n    top,\n    left,\n    height: bottom - top,\n    width: right - left\n  });\n}\n\nfunction windowRect() {\n  return new Rect({\n    top: window.scrollY,\n    left: window.scrollX,\n    height: window.innerHeight,\n    width: document.body.clientWidth\n  });\n}\n\nexport { calculateHorizontalPosition, calculateVerticalPosition, intersectionWithViewport, rectIsOutsideOfRect, windowRect };","map":{"version":3,"sources":["/Users/yewonkwak/Documents/GitHub/spacestagram/node_modules/@shopify/polaris/dist/esm/components/PositionedOverlay/utilities/math.js"],"names":["Rect","calculateVerticalPosition","activatorRect","overlayRect","overlayMargins","scrollableContainerRect","containerRect","preferredPosition","fixed","activatorTop","top","activatorBottom","height","spaceAbove","spaceBelow","desiredHeight","verticalMargins","activator","container","minimumSpaceToScroll","distanceToTopScroll","Math","max","distanceToBottomScroll","min","enoughSpaceFromTopScroll","enoughSpaceFromBottomScroll","heightIfBelow","heightIfAbove","containerRectTop","positionIfAbove","positioning","positionIfBelow","calculateHorizontalPosition","preferredAlignment","maximum","width","left","horizontal","activatorRight","center","x","rectIsOutsideOfRect","inner","outer","y","intersectionWithViewport","rect","viewport","windowRect","bottom","right","window","scrollY","scrollX","innerHeight","document","body","clientWidth"],"mappings":"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","sourcesContent":["import { Rect } from '../../../utilities/geometry.js';\n\nfunction calculateVerticalPosition(activatorRect, overlayRect, overlayMargins, scrollableContainerRect, containerRect, preferredPosition, fixed) {\n  const activatorTop = activatorRect.top;\n  const activatorBottom = activatorTop + activatorRect.height;\n  const spaceAbove = activatorRect.top;\n  const spaceBelow = containerRect.height - activatorRect.top - activatorRect.height;\n  const desiredHeight = overlayRect.height;\n  const verticalMargins = overlayMargins.activator + overlayMargins.container;\n  const minimumSpaceToScroll = overlayMargins.container;\n  const distanceToTopScroll = activatorRect.top - Math.max(scrollableContainerRect.top, 0);\n  const distanceToBottomScroll = containerRect.top + Math.min(containerRect.height, scrollableContainerRect.top + scrollableContainerRect.height) - (activatorRect.top + activatorRect.height);\n  const enoughSpaceFromTopScroll = distanceToTopScroll >= minimumSpaceToScroll;\n  const enoughSpaceFromBottomScroll = distanceToBottomScroll >= minimumSpaceToScroll;\n  const heightIfBelow = Math.min(spaceBelow, desiredHeight);\n  const heightIfAbove = Math.min(spaceAbove, desiredHeight);\n  const containerRectTop = fixed ? 0 : containerRect.top;\n  const positionIfAbove = {\n    height: heightIfAbove - verticalMargins,\n    top: activatorTop + containerRectTop - heightIfAbove,\n    positioning: 'above'\n  };\n  const positionIfBelow = {\n    height: heightIfBelow - verticalMargins,\n    top: activatorBottom + containerRectTop,\n    positioning: 'below'\n  };\n\n  if (preferredPosition === 'above') {\n    return (enoughSpaceFromTopScroll || distanceToTopScroll >= distanceToBottomScroll && !enoughSpaceFromBottomScroll) && (spaceAbove > desiredHeight || spaceAbove > spaceBelow) ? positionIfAbove : positionIfBelow;\n  }\n\n  if (preferredPosition === 'below') {\n    return (enoughSpaceFromBottomScroll || distanceToBottomScroll >= distanceToTopScroll && !enoughSpaceFromTopScroll) && (spaceBelow > desiredHeight || spaceBelow > spaceAbove) ? positionIfBelow : positionIfAbove;\n  }\n\n  if (enoughSpaceFromTopScroll && enoughSpaceFromBottomScroll) {\n    return spaceAbove > spaceBelow ? positionIfAbove : positionIfBelow;\n  }\n\n  return distanceToTopScroll > minimumSpaceToScroll ? positionIfAbove : positionIfBelow;\n}\nfunction calculateHorizontalPosition(activatorRect, overlayRect, containerRect, overlayMargins, preferredAlignment) {\n  const maximum = containerRect.width - overlayRect.width;\n\n  if (preferredAlignment === 'left') {\n    return Math.min(maximum, Math.max(0, activatorRect.left - overlayMargins.horizontal));\n  } else if (preferredAlignment === 'right') {\n    const activatorRight = containerRect.width - (activatorRect.left + activatorRect.width);\n    return Math.min(maximum, Math.max(0, activatorRight - overlayMargins.horizontal));\n  }\n\n  return Math.min(maximum, Math.max(0, activatorRect.center.x - overlayRect.width / 2));\n}\nfunction rectIsOutsideOfRect(inner, outer) {\n  const {\n    center\n  } = inner;\n  return center.y < outer.top || center.y > outer.top + outer.height;\n}\nfunction intersectionWithViewport(rect, viewport = windowRect()) {\n  const top = Math.max(rect.top, 0);\n  const left = Math.max(rect.left, 0);\n  const bottom = Math.min(rect.top + rect.height, viewport.height);\n  const right = Math.min(rect.left + rect.width, viewport.width);\n  return new Rect({\n    top,\n    left,\n    height: bottom - top,\n    width: right - left\n  });\n}\nfunction windowRect() {\n  return new Rect({\n    top: window.scrollY,\n    left: window.scrollX,\n    height: window.innerHeight,\n    width: document.body.clientWidth\n  });\n}\n\nexport { calculateHorizontalPosition, calculateVerticalPosition, intersectionWithViewport, rectIsOutsideOfRect, windowRect };\n"]},"metadata":{},"sourceType":"module"}