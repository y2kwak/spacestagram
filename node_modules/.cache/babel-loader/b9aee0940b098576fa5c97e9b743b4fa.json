{"ast":null,"code":"import { get as get$1 } from '../get.js';\nimport { merge as merge$1 } from '../merge.js';\nconst REPLACE_REGEX = /{([^}]*)}/g;\n\nclass I18n {\n  /**\n   * @param translation A locale object or array of locale objects that overrides default translations. If specifying an array then your desired language dictionary should come first, followed by your fallback language dictionaries\n   */\n  constructor(translation) {\n    this.translation = {}; // slice the array to make a shallow copy of it, so we don't accidentally\n    // modify the original translation array\n\n    this.translation = Array.isArray(translation) ? merge$1(...translation.slice().reverse()) : translation;\n  }\n\n  translate(id, replacements) {\n    const text = get$1(this.translation, id, '');\n\n    if (!text) {\n      return '';\n    }\n\n    if (replacements) {\n      return text.replace(REPLACE_REGEX, match => {\n        const replacement = match.substring(1, match.length - 1);\n\n        if (replacements[replacement] === undefined) {\n          const replacementData = JSON.stringify(replacements);\n          throw new Error(`Error in translation for key '${id}'. No replacement found for key '${replacement}'. The following replacements were passed: '${replacementData}'`);\n        } // This could be a string or a number, but JS doesn't mind which it gets\n        // and can handle that cast internally. So let it, to save us calling\n        // toString() on what's already a string in 90% of cases.\n\n\n        return replacements[replacement];\n      });\n    }\n\n    return text;\n  }\n\n  translationKeyExists(path) {\n    return Boolean(get$1(this.translation, path));\n  }\n\n}\n\nexport { I18n };","map":{"version":3,"sources":["/Users/yewonkwak/Documents/GitHub/spacestagram/node_modules/@shopify/polaris/dist/esm/utilities/i18n/I18n.js"],"names":["get","get$1","merge","merge$1","REPLACE_REGEX","I18n","constructor","translation","Array","isArray","slice","reverse","translate","id","replacements","text","replace","match","replacement","substring","length","undefined","replacementData","JSON","stringify","Error","translationKeyExists","path","Boolean"],"mappings":"AAAA,SAASA,GAAG,IAAIC,KAAhB,QAA6B,WAA7B;AACA,SAASC,KAAK,IAAIC,OAAlB,QAAiC,aAAjC;AAEA,MAAMC,aAAa,GAAG,YAAtB;;AACA,MAAMC,IAAN,CAAW;AACT;AACF;AACA;AACEC,EAAAA,WAAW,CAACC,WAAD,EAAc;AACvB,SAAKA,WAAL,GAAmB,EAAnB,CADuB,CAEvB;AACA;;AACA,SAAKA,WAAL,GAAmBC,KAAK,CAACC,OAAN,CAAcF,WAAd,IAA6BJ,OAAO,CAAC,GAAGI,WAAW,CAACG,KAAZ,GAAoBC,OAApB,EAAJ,CAApC,GAAyEJ,WAA5F;AACD;;AAEDK,EAAAA,SAAS,CAACC,EAAD,EAAKC,YAAL,EAAmB;AAC1B,UAAMC,IAAI,GAAGd,KAAK,CAAC,KAAKM,WAAN,EAAmBM,EAAnB,EAAuB,EAAvB,CAAlB;;AAEA,QAAI,CAACE,IAAL,EAAW;AACT,aAAO,EAAP;AACD;;AAED,QAAID,YAAJ,EAAkB;AAChB,aAAOC,IAAI,CAACC,OAAL,CAAaZ,aAAb,EAA4Ba,KAAK,IAAI;AAC1C,cAAMC,WAAW,GAAGD,KAAK,CAACE,SAAN,CAAgB,CAAhB,EAAmBF,KAAK,CAACG,MAAN,GAAe,CAAlC,CAApB;;AAEA,YAAIN,YAAY,CAACI,WAAD,CAAZ,KAA8BG,SAAlC,EAA6C;AAC3C,gBAAMC,eAAe,GAAGC,IAAI,CAACC,SAAL,CAAeV,YAAf,CAAxB;AACA,gBAAM,IAAIW,KAAJ,CAAW,iCAAgCZ,EAAG,oCAAmCK,WAAY,+CAA8CI,eAAgB,GAA3J,CAAN;AACD,SANyC,CAMxC;AACF;AACA;;;AAGA,eAAOR,YAAY,CAACI,WAAD,CAAnB;AACD,OAZM,CAAP;AAaD;;AAED,WAAOH,IAAP;AACD;;AAEDW,EAAAA,oBAAoB,CAACC,IAAD,EAAO;AACzB,WAAOC,OAAO,CAAC3B,KAAK,CAAC,KAAKM,WAAN,EAAmBoB,IAAnB,CAAN,CAAd;AACD;;AAvCQ;;AA2CX,SAAStB,IAAT","sourcesContent":["import { get as get$1 } from '../get.js';\nimport { merge as merge$1 } from '../merge.js';\n\nconst REPLACE_REGEX = /{([^}]*)}/g;\nclass I18n {\n  /**\n   * @param translation A locale object or array of locale objects that overrides default translations. If specifying an array then your desired language dictionary should come first, followed by your fallback language dictionaries\n   */\n  constructor(translation) {\n    this.translation = {};\n    // slice the array to make a shallow copy of it, so we don't accidentally\n    // modify the original translation array\n    this.translation = Array.isArray(translation) ? merge$1(...translation.slice().reverse()) : translation;\n  }\n\n  translate(id, replacements) {\n    const text = get$1(this.translation, id, '');\n\n    if (!text) {\n      return '';\n    }\n\n    if (replacements) {\n      return text.replace(REPLACE_REGEX, match => {\n        const replacement = match.substring(1, match.length - 1);\n\n        if (replacements[replacement] === undefined) {\n          const replacementData = JSON.stringify(replacements);\n          throw new Error(`Error in translation for key '${id}'. No replacement found for key '${replacement}'. The following replacements were passed: '${replacementData}'`);\n        } // This could be a string or a number, but JS doesn't mind which it gets\n        // and can handle that cast internally. So let it, to save us calling\n        // toString() on what's already a string in 90% of cases.\n\n\n        return replacements[replacement];\n      });\n    }\n\n    return text;\n  }\n\n  translationKeyExists(path) {\n    return Boolean(get$1(this.translation, path));\n  }\n\n}\n\nexport { I18n };\n"]},"metadata":{},"sourceType":"module"}