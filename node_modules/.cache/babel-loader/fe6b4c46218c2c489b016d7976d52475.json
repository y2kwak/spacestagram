{"ast":null,"code":"import React$1, { PureComponent } from 'react';\nimport { objectSpread2 as _objectSpread2 } from '../../_virtual/_rollupPluginBabelHelpers.js';\nimport { EventListener as EventListener$1 } from '../EventListener/EventListener.js';\nimport { layer } from '../shared.js';\nimport { getRectForNode, Rect } from '../../utilities/geometry.js';\nimport { classNames } from '../../utilities/css.js';\nimport { Scrollable as Scrollable$1 } from '../Scrollable/Scrollable.js';\nimport { windowRect, calculateVerticalPosition, calculateHorizontalPosition, rectIsOutsideOfRect, intersectionWithViewport } from './utilities/math.js';\nimport styles from './PositionedOverlay.scss.js';\nconst OBSERVER_CONFIG = {\n  childList: true,\n  subtree: true\n};\n\nclass PositionedOverlay extends PureComponent {\n  constructor(props) {\n    super(props);\n    this.state = {\n      measuring: true,\n      activatorRect: getRectForNode(this.props.activator),\n      right: undefined,\n      left: undefined,\n      top: 0,\n      height: 0,\n      width: null,\n      positioning: 'below',\n      zIndex: null,\n      outsideScrollableContainer: false,\n      lockPosition: false\n    };\n    this.overlay = null;\n    this.scrollableContainer = null;\n    this.observer = void 0;\n\n    this.overlayDetails = () => {\n      const {\n        measuring,\n        left,\n        right,\n        positioning,\n        height,\n        activatorRect\n      } = this.state;\n      return {\n        measuring,\n        left,\n        right,\n        desiredHeight: height,\n        positioning,\n        activatorRect\n      };\n    };\n\n    this.setOverlay = node => {\n      this.overlay = node;\n    };\n\n    this.handleMeasurement = () => {\n      const {\n        lockPosition,\n        top\n      } = this.state;\n      this.observer.disconnect();\n      this.setState(_ref => {\n        let {\n          left,\n          top,\n          right\n        } = _ref;\n        return {\n          left,\n          right,\n          top,\n          height: 0,\n          positioning: 'below',\n          measuring: true\n        };\n      }, () => {\n        if (this.overlay == null || this.scrollableContainer == null) {\n          return;\n        }\n\n        const {\n          activator,\n          preferredPosition = 'below',\n          preferredAlignment = 'center',\n          onScrollOut,\n          fullWidth,\n          fixed,\n          preferInputActivator = true\n        } = this.props;\n        const preferredActivator = preferInputActivator ? activator.querySelector('input') || activator : activator;\n        const activatorRect = getRectForNode(preferredActivator);\n        const currentOverlayRect = getRectForNode(this.overlay);\n        const scrollableElement = isDocument(this.scrollableContainer) ? document.body : this.scrollableContainer;\n        const scrollableContainerRect = getRectForNode(scrollableElement);\n        const overlayRect = fullWidth ? new Rect(_objectSpread2(_objectSpread2({}, currentOverlayRect), {}, {\n          width: activatorRect.width\n        })) : currentOverlayRect; // If `body` is 100% height, it still acts as though it were not constrained to that size. This adjusts for that.\n\n        if (scrollableElement === document.body) {\n          scrollableContainerRect.height = document.body.scrollHeight;\n        }\n\n        const overlayMargins = this.overlay.firstElementChild && this.overlay.firstChild instanceof HTMLElement ? getMarginsForNode(this.overlay.firstElementChild) : {\n          activator: 0,\n          container: 0,\n          horizontal: 0\n        };\n        const containerRect = windowRect();\n        const zIndexForLayer = getZIndexForLayerFromNode(activator);\n        const zIndex = zIndexForLayer == null ? zIndexForLayer : zIndexForLayer + 1;\n        const verticalPosition = calculateVerticalPosition(activatorRect, overlayRect, overlayMargins, scrollableContainerRect, containerRect, preferredPosition, fixed);\n        const horizontalPosition = calculateHorizontalPosition(activatorRect, overlayRect, containerRect, overlayMargins, preferredAlignment);\n        this.setState({\n          measuring: false,\n          activatorRect: getRectForNode(activator),\n          left: preferredAlignment !== 'right' ? horizontalPosition : undefined,\n          right: preferredAlignment === 'right' ? horizontalPosition : undefined,\n          top: lockPosition ? top : verticalPosition.top,\n          lockPosition: Boolean(fixed),\n          height: verticalPosition.height || 0,\n          width: fullWidth ? overlayRect.width : null,\n          positioning: verticalPosition.positioning,\n          outsideScrollableContainer: onScrollOut != null && rectIsOutsideOfRect(activatorRect, intersectionWithViewport(scrollableContainerRect)),\n          zIndex\n        }, () => {\n          if (!this.overlay) return;\n          this.observer.observe(this.overlay, OBSERVER_CONFIG);\n        });\n      });\n    };\n\n    this.observer = new MutationObserver(this.handleMeasurement);\n  }\n\n  componentDidMount() {\n    this.scrollableContainer = Scrollable$1.forNode(this.props.activator);\n\n    if (this.scrollableContainer && !this.props.fixed) {\n      this.scrollableContainer.addEventListener('scroll', this.handleMeasurement);\n    }\n\n    this.handleMeasurement();\n  }\n\n  componentWillUnmount() {\n    if (this.scrollableContainer && !this.props.fixed) {\n      this.scrollableContainer.removeEventListener('scroll', this.handleMeasurement);\n    }\n  }\n\n  componentDidUpdate() {\n    const {\n      outsideScrollableContainer,\n      top\n    } = this.state;\n    const {\n      onScrollOut,\n      active\n    } = this.props;\n\n    if (active && onScrollOut != null && top !== 0 && outsideScrollableContainer) {\n      onScrollOut();\n    }\n  }\n\n  render() {\n    const {\n      left,\n      right,\n      top,\n      zIndex,\n      width\n    } = this.state;\n    const {\n      render,\n      fixed,\n      preventInteraction,\n      classNames: propClassNames,\n      zIndexOverride\n    } = this.props;\n    const style = {\n      top: top == null || isNaN(top) ? undefined : top,\n      left: left == null || isNaN(left) ? undefined : left,\n      right: right == null || isNaN(right) ? undefined : right,\n      width: width == null || isNaN(width) ? undefined : width,\n      zIndex: zIndexOverride || zIndex || undefined\n    };\n    const className = classNames(styles.PositionedOverlay, fixed && styles.fixed, preventInteraction && styles.preventInteraction, propClassNames);\n    return /*#__PURE__*/React$1.createElement(\"div\", {\n      className: className,\n      style: style,\n      ref: this.setOverlay\n    }, /*#__PURE__*/React$1.createElement(EventListener$1, {\n      event: \"resize\",\n      handler: this.handleMeasurement\n    }), render(this.overlayDetails()));\n  }\n\n}\n\nfunction getMarginsForNode(node) {\n  const nodeStyles = window.getComputedStyle(node);\n  return {\n    activator: parseFloat(nodeStyles.marginTop || '0'),\n    container: parseFloat(nodeStyles.marginBottom || '0'),\n    horizontal: parseFloat(nodeStyles.marginLeft || '0')\n  };\n}\n\nfunction getZIndexForLayerFromNode(node) {\n  const layerNode = node.closest(layer.selector) || document.body;\n  const zIndex = layerNode === document.body ? 'auto' : parseInt(window.getComputedStyle(layerNode).zIndex || '0', 10);\n  return zIndex === 'auto' || isNaN(zIndex) ? null : zIndex;\n}\n\nfunction isDocument(node) {\n  return node === document;\n}\n\nexport { PositionedOverlay };","map":{"version":3,"sources":["/Users/yewonkwak/Documents/GitHub/spacestagram/node_modules/@shopify/polaris/dist/esm/components/PositionedOverlay/PositionedOverlay.js"],"names":["React$1","PureComponent","objectSpread2","_objectSpread2","EventListener","EventListener$1","layer","getRectForNode","Rect","classNames","Scrollable","Scrollable$1","windowRect","calculateVerticalPosition","calculateHorizontalPosition","rectIsOutsideOfRect","intersectionWithViewport","styles","OBSERVER_CONFIG","childList","subtree","PositionedOverlay","constructor","props","state","measuring","activatorRect","activator","right","undefined","left","top","height","width","positioning","zIndex","outsideScrollableContainer","lockPosition","overlay","scrollableContainer","observer","overlayDetails","desiredHeight","setOverlay","node","handleMeasurement","disconnect","setState","preferredPosition","preferredAlignment","onScrollOut","fullWidth","fixed","preferInputActivator","preferredActivator","querySelector","currentOverlayRect","scrollableElement","isDocument","document","body","scrollableContainerRect","overlayRect","scrollHeight","overlayMargins","firstElementChild","firstChild","HTMLElement","getMarginsForNode","container","horizontal","containerRect","zIndexForLayer","getZIndexForLayerFromNode","verticalPosition","horizontalPosition","Boolean","observe","MutationObserver","componentDidMount","forNode","addEventListener","componentWillUnmount","removeEventListener","componentDidUpdate","active","render","preventInteraction","propClassNames","zIndexOverride","style","isNaN","className","createElement","ref","event","handler","nodeStyles","window","getComputedStyle","parseFloat","marginTop","marginBottom","marginLeft","layerNode","closest","selector","parseInt"],"mappings":"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","sourcesContent":["import React$1, { PureComponent } from 'react';\nimport { objectSpread2 as _objectSpread2 } from '../../_virtual/_rollupPluginBabelHelpers.js';\nimport { EventListener as EventListener$1 } from '../EventListener/EventListener.js';\nimport { layer } from '../shared.js';\nimport { getRectForNode, Rect } from '../../utilities/geometry.js';\nimport { classNames } from '../../utilities/css.js';\nimport { Scrollable as Scrollable$1 } from '../Scrollable/Scrollable.js';\nimport { windowRect, calculateVerticalPosition, calculateHorizontalPosition, rectIsOutsideOfRect, intersectionWithViewport } from './utilities/math.js';\nimport styles from './PositionedOverlay.scss.js';\n\nconst OBSERVER_CONFIG = {\n  childList: true,\n  subtree: true\n};\nclass PositionedOverlay extends PureComponent {\n  constructor(props) {\n    super(props);\n    this.state = {\n      measuring: true,\n      activatorRect: getRectForNode(this.props.activator),\n      right: undefined,\n      left: undefined,\n      top: 0,\n      height: 0,\n      width: null,\n      positioning: 'below',\n      zIndex: null,\n      outsideScrollableContainer: false,\n      lockPosition: false\n    };\n    this.overlay = null;\n    this.scrollableContainer = null;\n    this.observer = void 0;\n\n    this.overlayDetails = () => {\n      const {\n        measuring,\n        left,\n        right,\n        positioning,\n        height,\n        activatorRect\n      } = this.state;\n      return {\n        measuring,\n        left,\n        right,\n        desiredHeight: height,\n        positioning,\n        activatorRect\n      };\n    };\n\n    this.setOverlay = node => {\n      this.overlay = node;\n    };\n\n    this.handleMeasurement = () => {\n      const {\n        lockPosition,\n        top\n      } = this.state;\n      this.observer.disconnect();\n      this.setState(({\n        left,\n        top,\n        right\n      }) => ({\n        left,\n        right,\n        top,\n        height: 0,\n        positioning: 'below',\n        measuring: true\n      }), () => {\n        if (this.overlay == null || this.scrollableContainer == null) {\n          return;\n        }\n\n        const {\n          activator,\n          preferredPosition = 'below',\n          preferredAlignment = 'center',\n          onScrollOut,\n          fullWidth,\n          fixed,\n          preferInputActivator = true\n        } = this.props;\n        const preferredActivator = preferInputActivator ? activator.querySelector('input') || activator : activator;\n        const activatorRect = getRectForNode(preferredActivator);\n        const currentOverlayRect = getRectForNode(this.overlay);\n        const scrollableElement = isDocument(this.scrollableContainer) ? document.body : this.scrollableContainer;\n        const scrollableContainerRect = getRectForNode(scrollableElement);\n        const overlayRect = fullWidth ? new Rect(_objectSpread2(_objectSpread2({}, currentOverlayRect), {}, {\n          width: activatorRect.width\n        })) : currentOverlayRect; // If `body` is 100% height, it still acts as though it were not constrained to that size. This adjusts for that.\n\n        if (scrollableElement === document.body) {\n          scrollableContainerRect.height = document.body.scrollHeight;\n        }\n\n        const overlayMargins = this.overlay.firstElementChild && this.overlay.firstChild instanceof HTMLElement ? getMarginsForNode(this.overlay.firstElementChild) : {\n          activator: 0,\n          container: 0,\n          horizontal: 0\n        };\n        const containerRect = windowRect();\n        const zIndexForLayer = getZIndexForLayerFromNode(activator);\n        const zIndex = zIndexForLayer == null ? zIndexForLayer : zIndexForLayer + 1;\n        const verticalPosition = calculateVerticalPosition(activatorRect, overlayRect, overlayMargins, scrollableContainerRect, containerRect, preferredPosition, fixed);\n        const horizontalPosition = calculateHorizontalPosition(activatorRect, overlayRect, containerRect, overlayMargins, preferredAlignment);\n        this.setState({\n          measuring: false,\n          activatorRect: getRectForNode(activator),\n          left: preferredAlignment !== 'right' ? horizontalPosition : undefined,\n          right: preferredAlignment === 'right' ? horizontalPosition : undefined,\n          top: lockPosition ? top : verticalPosition.top,\n          lockPosition: Boolean(fixed),\n          height: verticalPosition.height || 0,\n          width: fullWidth ? overlayRect.width : null,\n          positioning: verticalPosition.positioning,\n          outsideScrollableContainer: onScrollOut != null && rectIsOutsideOfRect(activatorRect, intersectionWithViewport(scrollableContainerRect)),\n          zIndex\n        }, () => {\n          if (!this.overlay) return;\n          this.observer.observe(this.overlay, OBSERVER_CONFIG);\n        });\n      });\n    };\n\n    this.observer = new MutationObserver(this.handleMeasurement);\n  }\n\n  componentDidMount() {\n    this.scrollableContainer = Scrollable$1.forNode(this.props.activator);\n\n    if (this.scrollableContainer && !this.props.fixed) {\n      this.scrollableContainer.addEventListener('scroll', this.handleMeasurement);\n    }\n\n    this.handleMeasurement();\n  }\n\n  componentWillUnmount() {\n    if (this.scrollableContainer && !this.props.fixed) {\n      this.scrollableContainer.removeEventListener('scroll', this.handleMeasurement);\n    }\n  }\n\n  componentDidUpdate() {\n    const {\n      outsideScrollableContainer,\n      top\n    } = this.state;\n    const {\n      onScrollOut,\n      active\n    } = this.props;\n\n    if (active && onScrollOut != null && top !== 0 && outsideScrollableContainer) {\n      onScrollOut();\n    }\n  }\n\n  render() {\n    const {\n      left,\n      right,\n      top,\n      zIndex,\n      width\n    } = this.state;\n    const {\n      render,\n      fixed,\n      preventInteraction,\n      classNames: propClassNames,\n      zIndexOverride\n    } = this.props;\n    const style = {\n      top: top == null || isNaN(top) ? undefined : top,\n      left: left == null || isNaN(left) ? undefined : left,\n      right: right == null || isNaN(right) ? undefined : right,\n      width: width == null || isNaN(width) ? undefined : width,\n      zIndex: zIndexOverride || zIndex || undefined\n    };\n    const className = classNames(styles.PositionedOverlay, fixed && styles.fixed, preventInteraction && styles.preventInteraction, propClassNames);\n    return /*#__PURE__*/React$1.createElement(\"div\", {\n      className: className,\n      style: style,\n      ref: this.setOverlay\n    }, /*#__PURE__*/React$1.createElement(EventListener$1, {\n      event: \"resize\",\n      handler: this.handleMeasurement\n    }), render(this.overlayDetails()));\n  }\n\n}\n\nfunction getMarginsForNode(node) {\n  const nodeStyles = window.getComputedStyle(node);\n  return {\n    activator: parseFloat(nodeStyles.marginTop || '0'),\n    container: parseFloat(nodeStyles.marginBottom || '0'),\n    horizontal: parseFloat(nodeStyles.marginLeft || '0')\n  };\n}\n\nfunction getZIndexForLayerFromNode(node) {\n  const layerNode = node.closest(layer.selector) || document.body;\n  const zIndex = layerNode === document.body ? 'auto' : parseInt(window.getComputedStyle(layerNode).zIndex || '0', 10);\n  return zIndex === 'auto' || isNaN(zIndex) ? null : zIndex;\n}\n\nfunction isDocument(node) {\n  return node === document;\n}\n\nexport { PositionedOverlay };\n"]},"metadata":{},"sourceType":"module"}